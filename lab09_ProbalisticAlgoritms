# lab09_ProbalisticAlgoritms

## PreLab

### P1: How do you compute the area of a circle and a rectangle?

Circle:

```matlab
A = PI * r^2
```

Rectangle:

```matlab
A = a*b
```



### P2: Draw an circle that matches exactly into a square. How do the areas of the circle and the square relate to each other? 

- the radius of the circle matches the length the rectangles side




### P3: How can you represent points in a plane? 

- as a Matrix




### P4: Prepare a sketch with formulas about the ratio of the areas and how to determine if a given point in the square is as well within the circle. 







## Computation of Pi

###  P1: create a method computePi that takes an integer parameter for the number of random points to consider.

```java
private static void computePi(int random) {
        double computedPi = 0.0;
        double zaehler = 1;

        for (int i = 0; i < random; i++) {
            if (i % 2 == 0) {
                computedPi = computedPi + (1.0 / zaehler);
            } else {
                computedPi = computedPi - (1.0 / zaehler);
            }
        zaehler += 2;
        }
        computedPi = computedPi * 4.0;
        System.out.println("Calculated Pi is: " + computedPi);
```

- we´ve used the Leibniz-Formula to calculate Pi with a variable iteration length
  - `pi = 4(1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + ... + 1/2n-1 - 1/2n+1)`
- the modulo operation enables us to alternate between addition and subtraction




### P2: create a method that creates a random point within the square bounds. 

```java
private static Point2D createRndPoints() {
        int rndX = (int) (Math.random() * (WIDTH));
        int rndY = (int) (Math.random() * (HEIGHT));
        return new Point2D.Double(rndX, rndY);
    }
```

- we´ve used the class Point2D to hold coordinates for 1 point
- The x and y coordinates are randomly generated by using `Math.random` and the specified `width` and `height` (for this example `width = height`)




### P3: for each point, determine wether it is also within the circle - create a third method for that. 

```java
private static boolean isInCircle(Point2D rndPoint) {
        //Strecken der Punkte für Berechnung mit Pythagoras
        int circleMidX = WIDTH / 2;
        int deltaX = (int) (rndPoint.getX()) - circleMidX;
        int circleMidY = HEIGHT / 2;
        int deltaY = (int) (rndPoint.getY()) - circleMidY;
        //Hypotenuse
        double d = Math.pow(deltaX, 2) + Math.pow(deltaY, 2);
        return d < RADIUS * RADIUS;
    }
```

- to calculate if a point is in the square **and** the circle we have to use Pythagoras to calculate the points distance to the shared midpoint of circle and square
- if the distance is smaller or equal than the radius of the circle the point is inside both geometries, if not it is outside the circle




### P4: the ratio of points within the circle to the whole number of points within the square approximates the ratio of the areas. Use it to approximate Pi. 

```java
private static void approximatePi() {
        approxPi = inside * 4 / all;
        System.out.println("Approximated Pi is: " + approxPi);
    }
```

- this formula is derived from the area formula for a square and a circle




### P5: make a statistic about how many accurate digits of Pi you get for how many random points. 

| iterations | Approx. Pi | Math.Pi           | correct decimals |
| ---------- | ---------- | ----------------- | ---------------- |
| 1000       | 3.132      | 3.141592653589793 | 1                |
| 10.000     | 3.1504     | 3.141592653589793 | 1                |
| 100.000    | 3.14488    | 3.141592653589793 | 2                |
| 1.000.000  | 3.141576   | 3.141592653589793 | 4                |
| 10.000.000 | 3.1415496  | 3.141592653589793 | 5                |

- we can see that with incresing iterations the precision increases



## Dining Philosophers

### P1 / P2: Using threads, create a simple Simulation for the Dining Philosophers Problem. For each Philosopher, create a Thread within this Philosopher dines. 

To simulate the Dining Philosophers Problem we need to create 5 instances of a Philosopher that are then started as a Thread.

```java
public class DiningTable{

    private static Philosopher[] philosophers = new Philosopher[5];
    private Fork[] forks = new Fork[5];
    private Thread[] threads = new Thread[5];
  
    private DiningTable() {
    }

    public static void main(String[] args) {
        DiningTable table = new DiningTable();
        table.init();
    }

    private void init() {
        for (int i = 0; i < philosophers.length; i++) {
            forks[i] = new Fork(i);
            philosophers[i] = new Philosopher(i, leftFork, rightFork);
            threads[i] = new Thread (philosophers[i]);
            threads[i].start();
        }
    }
}
```

Every Philosopher shall think, eat with two forks and then start thinking again.

```java
// PSEUDO CODE
class Philosopher implements Runnables{
  private int ID;
  public Philosopher(int ID){
 		this.ID = ID;
  }
  
  @Override 
  public void run(){
    while (true){
      think();
      take_leftFork();
      take_rightFork();
      eat();
      drop_leftFork();
      drop_rightFork();
    }
  }
}
```

This will create a situation in which all Philosophers are taking their left forks and try to get the right fork which is not possible because all forks are currently in use. This is called a deadlock.



### P3: Provide several implementations with a sensible way to switch between them; at least one blocking one and one using a probabilistic solution to avoid the deadlock. 

To get a synchronization of all the Philosophers we tried implementing a left and a right fork as a mutex using the keyword `synchronized`. The left and right fork were given to the Philosopher as a constructor parameter from the DiningTable class.

```java
@Override
    public void run() {
        while (true) {
            think();
            synchronized (leftFork) {
                take_leftFork();
                synchronized (rightFork) {
                    take_rightFork();
                    eat();
                }
            }
            drop_leftFork();
            drop_rightFork();

            endTime = System.currentTimeMillis();
            duration = endTime - startTime;
            System.out.println(duration);
        }
    }
```

Further we have implemented a random waiting time for each philosophers action.

This seemed to work because we were now getting no Exceptions anymore and our program seemed to run infinitely with every Philosopher eating randomly.  Still there was the probability of deadlocks.

This could be avoided by using `this` as the mutex.

When we got the synchronization to work we we were wondering how many times each Philosopher has eaten so we´ve implemented a way of counting and printing the occurencies of each philosopher eating in fixed amount of time. We have decided to set this time to approx. 5 seconds. By this we could check if the algorithm is working properly and also be able to try out some ways to improve the algorithm.

|                                 | Ph #0 | Ph #1 | Ph #2 | Ph  #3 | Ph #4 |
| ------------------------------- | ----- | ----- | ----- | ------ | ----- |
| mutex = fork (rand bound = 100) | 10    | 10    | 9     | 9      | 10    |
| mutex = fork (rand bound = 10)  | 104   | 104   | 107   | 106    | 102   |
| mutex = this (rand bound = 100) | 16    | 17    | 17    | 18     | 17    |
| mutex = this (rand bound = 10)  | 161   | 163   | 161   | 166    |       |

We can now see that from the tested implementations the one using `this` as mutex and a random bound of 10 gives us the best results.